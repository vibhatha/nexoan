// AUTO-GENERATED FILE.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/http;
import ballerina/protobuf.types.'any as pbAny;
import ballerina/io;
import ballerina/lang.'int as langint;
import ballerina/grpc;
import ballerina/log;

// BAL_CONFIG_VAR_CRUDSERVICEURL
configurable string crudServiceUrl = "http://localhost:50051";
// BAL_CONFIG_VAR_UPDATESERVICEHOST
configurable string updateServiceHost = "0.0.0.0";
// BAL_CONFIG_VAR_UPDATESERVICEPORT
configurable string updateServicePort = "8080";


listener http:Listener ep0 = new (check langint:fromString(updateServicePort), config = {
    host: updateServiceHost,
    httpVersion: http:HTTP_2_0
});

// Create gRPC client with proper configuration for HTTP/2
grpc:ClientConfiguration grpcConfig = {
    timeout: 300000, // 5 minutes timeout
    secureSocket: {
        enable: false // Disable TLS for insecure connection
    }
};

CrudServiceClient ep = check new (crudServiceUrl, grpcConfig);

// Helper function to convert decimal values to float for protobuf compatibility
// Note that this is a temporary solution to convert decimal values to float for protobuf compatibility.
// It is not a permanent solution and should be removed when the protobuf library is updated to support decimal values.
// FIXME: https://github.com/LDFLK/nexoan/issues/287
function convertDecimalToFloat(json data) returns json {
    if data is decimal {
        // Convert decimal to float for protobuf compatibility
        return <float>data;
    } else if data is json[] {
        // Handle arrays - recursively convert each element
        json[] convertedArray = [];
        foreach var item in data {
            convertedArray.push(convertDecimalToFloat(item));
        }
        return convertedArray;
    } else if data is map<json> {
        // Handle maps - recursively convert each value
        map<json> convertedMap = {};
        foreach var [key, value] in data.entries() {
            convertedMap[key] = convertDecimalToFloat(value);
        }
        return convertedMap;
    } else {
        // For other types (int, string, boolean, etc.), return as-is
        return data;
    }
}

// Helper function to convert JSON to protobuf Any value
function convertJsonToAny(json data) returns pbAny:Any|error {
    // First, convert any decimal values to float for protobuf compatibility
    // FIXME: https://github.com/LDFLK/nexoan/issues/287
    json convertedData = convertDecimalToFloat(data);
    
    if convertedData is int {
        // For integer values
        map<json> structMap = {
            "value": convertedData
        };
        return pbAny:pack(structMap);
    } else if convertedData is float {
        // For float values
        map<json> structMap = {
            "value": convertedData
        };
        return pbAny:pack(structMap);
    } else if convertedData is string {
        // For string values
        map<json> structMap = {
            "value": convertedData
        };
        return pbAny:pack(structMap);
    } else if convertedData is boolean {
        // For boolean values
        map<json> structMap = {
            "value": convertedData
        };
        return pbAny:pack(structMap);
    } else if convertedData is () {
        // For null values
        map<json> structMap = {
            "null_value": ()
        };
        return pbAny:pack(structMap);
    } else if convertedData is json[] {
        // For arrays, wrap in a list_value structure
        map<json> structMap = {
            "values": convertedData
        };
        return pbAny:pack(structMap);
    } else if convertedData is map<json> {
        // For objects, pack directly as structured data instead of converting to string
        return pbAny:pack(convertedData);
    } else {
        return error("Unsupported data type: " + convertedData.toString());
    }
}

service / on ep0 {
    # Delete an entity
    #
    # + return - Entity deleted 
    resource function delete entities/[string id]() returns http:NoContent|error {
        var result = ep->DeleteEntity({id: id});
        if result is error {
            io:println("gRPC DeleteEntity failed: ", result.message());
            return result;
        }
        return http:NO_CONTENT;
    }

    # Create a new entity
    #
    # + return - Entity created 
    resource function post entities(@http:Payload json jsonPayload) returns Entity|error {
        // Convert JSON to Entity with custom mapping
        io:println("[CreateEntity] jsonPayload: ", jsonPayload);
        Entity payload = check convertJsonToEntity(jsonPayload);
        
        io:println("[CreateEntity] Protobuf Payload: ", payload);
        
        var result = ep->CreateEntity(payload);
        if result is error {
            log:printError("gRPC CreateEntity failed: ", result);
        }
        return result;
    }

    # Update an existing entity
    #
    # + return - Entity updated 
    resource function put entities/[string id](@http:Payload json jsonPayload) returns Entity|error {
        // Convert JSON to Entity with custom mapping
        Entity payload = check convertJsonToEntity(jsonPayload);

        // Create UpdateEntityRequest with both id from URL and entity from payload
        UpdateEntityRequest updateRequest = {
            id: id,
            entity: payload
        };
        
        var result = ep->UpdateEntity(updateRequest);
        if result is error {
            log:printError("gRPC UpdateEntity failed: ", result);
        }
        return result;
    }

    # FIXME: https://github.com/LDFLK/nexoan/issues/135 
    # TODO: Remove/Don't expose this endpoint from Ingest API (has been only added for testing purposes)
    # Read an entity by ID
    #
    # + id - The ID of the entity to retrieve
    # + return - The entity or an error
    resource function get entities/[string id]() returns Entity|error {
        // Call the ReadEntity function with the ID
        ReadEntityRequest readEntityRequest = {
            entity: {
                id: id,
                kind: {},
                created: "",
                terminated: "",
                name: {
                    startTime: "",
                    endTime: "",
                    value: check pbAny:pack("")
                },
                metadata: [],
                attributes: [],
                relationships: []
            },
            output: ["metadata", "attributes", "relationships"]
        };
        
        Entity|error result = ep->ReadEntity(readEntityRequest);

        if result is error {
            log:printError("gRPC ReadEntity failed: ", result);
            return result;
        } else {
            io:println("Retrieved entity with ID: ", id);
            io:println("Entity metadata: ", result.metadata);
            io:println("Entity attributes: ", result.attributes);
            io:println("Entity relationships: ", result.relationships);
        }
        
        // Successfully retrieved the entity
        return result;
    }
}

// Helper function to convert JSON to Entity
function convertJsonToEntity(json jsonPayload) returns Entity|error {
    // Check if metadata is present and handle accordingly
    record {| string key; pbAny:Any value; |}[] metadataArray = [];

    if jsonPayload.metadata != () {
        if jsonPayload?.metadata is json[] {
            json[] metadataJsonArray = <json[]>check jsonPayload.metadata;
            foreach json item in metadataJsonArray {
                string key = (check item.key).toString();
                pbAny:Any packedValue = check pbAny:pack((check item.value).toString());
                metadataArray.push({key: key, value: packedValue});
            }
        } else if jsonPayload?.metadata is map<json> {
            map<json> metadataMap = <map<json>>check jsonPayload.metadata;
            foreach var [key, val] in metadataMap.entries() {
                pbAny:Any packedValue = check pbAny:pack(val.toString());
                metadataArray.push({key: key, value: packedValue});
            }
        }
    }
    
    // Process attributes if present
    record {| string key; TimeBasedValueList value; |}[] attributesArray = [];
    
    if jsonPayload.attributes != () {
        if jsonPayload?.attributes is json[] {
            json[] attributesJsonArray = <json[]>check jsonPayload.attributes;
            foreach json item in attributesJsonArray {
                string key = (check item.key).toString();
                // Add safe type checking for value
                json valueJson = check item.value;
                TimeBasedValue[] timeBasedValues = [];
                
                if valueJson is json[] {
                    json[] valuesJson = <json[]>valueJson;
                    foreach json valueItem in valuesJson {
                        TimeBasedValue tbv = {
                            startTime: (check valueItem.startTime).toString(),
                            endTime: valueItem?.endTime is () ? "" : (check valueItem.endTime).toString(),
                            value: check pbAny:pack((check valueItem.value).toString())
                        };
                        timeBasedValues.push(tbv);
                    }
                } else {
                    // Handle the case when value is not an array (could be a single object)
                    // Create a single TimeBasedValue object
                    json[] valuesJson = <json[]>check valueJson.values;

                    foreach json valueItem in valuesJson {
                        string startTime = valueItem?.startTime is () ? "" : (check valueItem.startTime).toString();
                        string endTime = valueItem?.endTime is () ? "" : (check valueItem.endTime).toString();
                        json value = valueItem?.value is () ? "" : (check valueItem.value).toJson();
                        // Access specific keys for tabular data
                        pbAny:Any tbvValue = check convertJsonToAny(value);
                        
                        TimeBasedValue tbv = {
                            startTime: startTime,
                            endTime: endTime,
                            value: tbvValue
                        };
                        timeBasedValues.push(tbv);
                    }
                }
                
                TimeBasedValueList tbvList = {
                    values: timeBasedValues
                };
                
                attributesArray.push({key: key, value: tbvList});
            }
        } else if jsonPayload?.attributes is map<json> {
            map<json> attributesMap = <map<json>>check jsonPayload.attributes;
            foreach var [key, val] in attributesMap.entries() {
                TimeBasedValue[] timeBasedValues = [];
                
                // Add safe type checking for val
                if val is json[] {
                    json[] valuesJson = <json[]>val;
                    foreach json valueItem in valuesJson {
                        TimeBasedValue tbv = {
                            startTime: (check valueItem.startTime).toString(),
                            endTime: valueItem?.endTime is () ? "" : (check valueItem.endTime).toString(),
                            value: check pbAny:pack((check valueItem.value).toString())
                        };
                        timeBasedValues.push(tbv);
                    }
                } else {
                    // Handle the case when val is not an array
                    TimeBasedValue tbv = {
                        startTime: val?.startTime is () ? "" : (check val.startTime).toString(),
                        endTime: val?.endTime is () ? "" : (check val.endTime).toString(),
                        value: check pbAny:pack(val?.value is () ? "" : (check val.value).toString())
                    };
                    timeBasedValues.push(tbv);
                }
                
                TimeBasedValueList tbvList = {
                    values: timeBasedValues
                };
                
                attributesArray.push({key: key, value: tbvList});
            }
        }
    }
    
    // Process relationships if present
    record {| string key; Relationship value; |}[] relationshipsArray = [];
    
    if jsonPayload.relationships != () {
        if jsonPayload?.relationships is json[] {
            json[] relationshipsJsonArray = <json[]>check jsonPayload.relationships;
            foreach json item in relationshipsJsonArray {
                string key = (check item.key).toString();
                json relJson = check item.value;
                
                Relationship relationship = {
                    relatedEntityId: (check relJson.relatedEntityId).toString(),
                    startTime: (check relJson.startTime).toString(),
                    endTime: relJson?.endTime is () ? "" : (check relJson.endTime).toString(),
                    id: (check relJson.id).toString(),
                    name: (check relJson.name).toString()
                };
                
                relationshipsArray.push({key: key, value: relationship});
            }
        } else if jsonPayload?.relationships is map<json> {
            map<json> relationshipsMap = <map<json>>check jsonPayload.relationships;
            foreach var [key, val] in relationshipsMap.entries() {
                // Ensure all required relationship fields are present and have default values if missing
                string relatedEntityId = val?.relatedEntityId is () ? "" : (check val.relatedEntityId).toString();
                string startTime = val?.startTime is () ? "" : (check val.startTime).toString();
                string endTime = val?.endTime is () ? "" : (check val.endTime).toString();
                string id = val?.id is () ? "" : (check val.id).toString();
                string name = val?.name is () ? key : (check val.name).toString(); // Default to key if name is missing
                
                Relationship relationship = {
                    relatedEntityId: relatedEntityId,
                    startTime: startTime,
                    endTime: endTime,
                    id: id,
                    name: name
                };
                
                relationshipsArray.push({key: key, value: relationship});
            }
        }
    }
    
    // Handle missing kind values
    json kindJson = {};
    if jsonPayload?.kind is () {
        kindJson = {"major": "", "minor": ""};
    } else {
        kindJson = check jsonPayload.kind;
    }
    string majorValue = kindJson?.major is () ? "" : (check kindJson.major).toString();
    string minorValue = kindJson?.minor is () ? "" : (check kindJson.minor).toString();
    
    // Handle missing name values
    json nameJson = {};
    if jsonPayload?.name is () {
        nameJson = {"startTime": "", "endTime": "", "value": ""};
    } else {
        nameJson = check jsonPayload.name;
    }
    string startTimeValue = nameJson?.startTime is () ? "" : (check nameJson.startTime).toString();
    string endTimeValue = nameJson?.endTime is () ? "" : (check nameJson.endTime).toString();
    string nameValue = nameJson?.value is () ? "" : (check nameJson.value).toString();
    
    // Pack name value using safe approach
    pbAny:Any namePackedValue;
    if nameValue == "" {
        namePackedValue = check pbAny:pack("");
    } else {
        namePackedValue = check pbAny:pack(nameValue);
    }
    
    // Create the entity with proper type reference and safe handling
    Entity entity = {
        id: jsonPayload?.id is () ? "" : (check jsonPayload.id).toString(),
        kind: {
            major: majorValue,
            minor: minorValue
        },
        created: jsonPayload?.created is () ? "" : (check jsonPayload.created).toString(),
        terminated: jsonPayload?.terminated is () ? "" : (check jsonPayload.terminated).toString(),
        name: {
            startTime: startTimeValue,
            endTime: endTimeValue,
            value: namePackedValue
        },
        metadata: metadataArray,
        attributes: attributesArray,
        relationships: relationshipsArray
    };
    
    return entity;
}
