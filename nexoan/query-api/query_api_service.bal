// AUTO-GENERATED FILE.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/http;
import ballerina/protobuf.types.'any;
import ballerina/grpc;
import ballerina/lang.'int as langint;
import ballerina/io;
import ballerina/protobuf.types.'any as pbAny;

// BAL_CONFIG_VAR_CRUDSERVICEURL
configurable string crudServiceUrl = "http://localhost:50051";
// BAL_CONFIG_VAR_QUERYSERVICEHOST
configurable string queryServiceHost = "0.0.0.0";
// BAL_CONFIG_VAR_QUERYSERVICEPORT
configurable string queryServicePort = "8081";

listener http:Listener ep0 = new (check langint:fromString(queryServicePort), config = {
    host: queryServiceHost,
    httpVersion: http:HTTP_2_0
});

// Create gRPC client with proper configuration for HTTP/2
grpc:ClientConfiguration grpcConfig = {
    timeout: 300000, // 5 minutes timeout
    secureSocket: {
        enable: false // Disable TLS for insecure connection
    }
};

CrudServiceClient ep = check new (crudServiceUrl, grpcConfig);

// Helper function to extract string representation based on typeUrl
function extractValueAsString('any:Any anyValue) returns string {
    string typeUrl = anyValue.typeUrl;
    
    // Default to using the value's string representation
    string valueStr = anyValue.toString();
    
    // Check if it's a known primitive type and handle accordingly
    if (typeUrl.endsWith("string")) {
        return anyValue.value.toString();
    } else if (typeUrl.endsWith("int32") || typeUrl.endsWith("int64") || 
             typeUrl.endsWith("float") || typeUrl.endsWith("double")) {
        return anyValue.value.toString();
    } else if (typeUrl.endsWith("bool")) {
        return anyValue.value.toString();
    } else {
        // For complex types, attempt to return as JSON string if possible
        return valueStr;
    }
}

service /v1 on ep0 {
    # Get entity attribute
    #
    # + return - Attribute value(s) 
    resource function get entities/[string entityId]/attributes/[string attributeName](string? startTime, string? endTime) returns record {string 'start?; string end?; string value?;}|record {string 'start?; string end?; string value?;}[]|http:NotFound|error {
        // Create entity filter with specific attribute and time range
        Entity entityFilter = {
            id: entityId,
            kind: {
                major: "",
                minor: ""
            },
            created: "",
            terminated: "",
            name: {
                startTime: "",
                endTime: "",
                value: {
                    typeUrl: "type.googleapis.com/google.protobuf.StringValue",
                    value: ""
                }
            },
            metadata: [],
            attributes: [
                {
                    key: attributeName,
                    value: {
                        values: [
                            {
                                startTime: startTime ?: "",
                                endTime: endTime ?: "",
                                value: {
                                    typeUrl: "type.googleapis.com/google.protobuf.StringValue",
                                    value: ""
                                }
                            }
                        ]
                    }
                }
            ],
            relationships: []
        };
        
        // Create ReadEntityRequest with output field set to attributes only
        ReadEntityRequest request = {
            entity: entityFilter,
            output: ["attributes"]  // Only request attributes field
        };
        
        // Read the entity using the crud service
        Entity entity = check ep->ReadEntity(request);
        
        // Process the filtered entity
        foreach var attrEntry in entity.attributes {
            if attrEntry.key == attributeName {
                TimeBasedValueList tbvList = attrEntry.value;
                
                // If we have time parameters, filter the results
                if tbvList.values.length() == 0 {
                    // Return empty array instead of null
                    return []; 
                } else if (tbvList.values.length() == 1) {
                    // Return single value
                    TimeBasedValue tbv = tbvList.values[0];
                    record {string 'start?; string end?; string value?;} response = {
                        'start: tbv.startTime,
                        end: tbv.endTime,
                        value: extractValueAsString(tbv.value)
                    };
                    return response;
                } else {
                    // Return multiple values
                    record {string 'start?; string end?; string value?;}[] response = [];
                    foreach var tbv in tbvList.values {
                        response.push({
                            'start: tbv.startTime,
                            end: tbv.endTime,
                            value: extractValueAsString(tbv.value)
                        });
                    }
                    return response;
                }
            }
        }
        
        // Return 404 with a message instead of null
        return <http:NotFound> {
            body: {
                "error": "Attribute not found",
                "attribute": attributeName,
                "entityId": entityId
            }
        };
    }

    # Get metadata of an entity
    #
    # + return - Entity metadata 
    resource function get entities/[string entityId]/metadata() returns EntitiesEntityIdMetadataResponse|error {
        // Create entity filter with empty fields
        Entity entityFilter = {
            id: entityId,
            kind: {
                major: "",
                minor: ""
            },
            created: "",
            terminated: "",
            name: {
                startTime: "",
                endTime: "",
                value: {
                    typeUrl: "",
                    value: ""
                }
            },
            metadata: [],
            attributes: [],
            relationships: []
        };

        // Create ReadEntityRequest with output field set to metadata only
        ReadEntityRequest request = {
            entity: entityFilter,
            output: ["metadata"]  // Only request metadata field
        };
        
        // Read the entity using the crud service
        Entity entity = check ep->ReadEntity(request);
        
        // Convert metadata to generic JSON object
        map<json> metadataJson = {};
        
        // Add all metadata fields
        foreach var entry in entity.metadata {
            metadataJson[entry.key] = extractValueAsString(entry.value);
        }
        
        return metadataJson;
    }

    # Get root entity IDs of a given kind
    #
    # + return - List of root entity IDs 
    resource function get entities/root(string kind) returns inline_response_200 {
        // TODO: implement this once the root entity IDs are identified
        return {};
    }

    # Get related entity IDs
    #
    # + return - List of related entities 
    resource function post entities/[string entityId]/relations(@http:Payload entityId_relations_body payload) returns RecordStringidStringrelatedEntityIdStringnameStringstartTimeStringendTimeStringdirectionArrayOk|http:BadRequest|error {
        // Validate that startTime/endTime and activeAt are not used together
        boolean hasTimeRange = (payload.startTime is string && payload.startTime != "") || (payload.endTime is string && payload.endTime != "");
        boolean hasActiveAt = payload.activeAt is string && payload.activeAt != "";
        
        if (hasTimeRange && hasActiveAt) {
            return <http:BadRequest> {
                body: {
                    "error": "Invalid request parameters",
                    "details": "Cannot use both time range (startTime/endTime) and activeAt parameters together. Use either time range or activeAt, but not both."
                }
            };
        }
        
        // Create entity filter with embedded relationship criteria
        Entity entityFilter = {
            id: entityId,
            kind: {
                major: "",
                minor: ""
            },
            created: "",
            terminated: "",
            name: {
                startTime: "",
                endTime: "",
                value: check pbAny:pack("")
            },
            metadata: [],
            attributes: [],
            relationships: [
                {
                    key: payload.id ?: "",  // Using id as the key
                    value: {
                        relatedEntityId: payload.relatedEntityId ?: "",
                        startTime: payload.startTime ?: "",
                        endTime: payload.endTime ?: "",
                        id: payload.id ?: "",
                        name: payload.name ?: "",
                        direction: payload.direction ?: ""
                    }
                }
            ]
        };
        
        // Create ReadEntityRequest with output field set to relationships only
        ReadEntityRequest request = {
            entity: entityFilter,
            output: ["relationships"],  // Only request relationships field
            activeAt: payload.activeAt ?: ""
        };
        
        // Read the entity using the crud service
        Entity entity = check ep->ReadEntity(request);
        
        // Process the relationships returned by the backend
        record {string id?; string relatedEntityId?; string name?; string startTime?; string endTime?; string direction?;}[] relationships = [];
        
        foreach var relEntry in entity.relationships {
            Relationship rel = relEntry.value;
            
            // Add to our result list
            relationships.push({
                id: rel.id,
                relatedEntityId: rel.relatedEntityId,
                name: rel.name,
                startTime: rel.startTime,
                endTime: rel.endTime,
                direction: rel.direction
            });
        }
        
        return <RecordStringidStringrelatedEntityIdStringnameStringstartTimeStringendTimeStringdirectionArrayOk>{body: relationships};
    }

    # Find entities based on criteria
    #
    # + return - List of matching entities 
    resource function post entities/search(@http:Payload entities_search_body payload) returns InlineResponse2001Ok|http:BadRequest|error {
        // Check if we have either ID or Kind.Major
        if payload.id == "" && (payload.kind is () || (<entitiessearch_kind>payload.kind)?.major is () || (<entitiessearch_kind>payload.kind)?.major == "") {
            return <http:BadRequest> {
                body: {
                    "error": "Invalid search criteria",
                    "details": "Either id or Kind.Major is required for filtering entities"
                }
            };
        }

        // Extract kind fields if they exist
        string kindMajor = "";
        string kindMinor = "";
        if payload.kind is entitiessearch_kind {
            entitiessearch_kind kind = <entitiessearch_kind>payload.kind;
            kindMajor = kind?.major ?: "";
            kindMinor = kind?.minor ?: "";
        }

        Entity entityFilter = {
            id: payload.id ?: "",
            kind: {
                major: kindMajor,
                minor: kindMinor
            },
            created: payload.created ?: "",
            terminated: payload.terminated ?: "",
            name: {
                startTime: "",
                endTime: "",
                value: check 'any:pack(payload.name ?: "")
            },
            metadata: [],
            attributes: [],
            relationships: []
        };

        ReadEntityRequest request = {
            entity: entityFilter,
            output: [] // Return all fields by default
        };

        // Call the ReadEntities method
        EntityList|error entityList = ep->ReadEntities(request);
        if entityList is error {
            io:println(string `Error reading entities: ${entityList.message()}`);
            
            return <http:BadRequest> {
                body: {
                    "error": "Invalid search criteria",
                    "details": entityList.message()
                }
            };
        }

        // Map the result to the expected response format
        record {string id?; record {string major?; string minor?;} kind?; string name?; string created?; string terminated?;}[] response = [];
        foreach var entity in entityList.entities {
            response.push({
                id: entity.id,
                kind: {major: entity.kind.major, minor: entity.kind.minor},
                name: extractValueAsString(entity.name.value),
                created: entity.created,
                terminated: entity.terminated
            });
        }
        return <InlineResponse2001Ok> {
            body: {
                body: response
            }
        };
    }
}
